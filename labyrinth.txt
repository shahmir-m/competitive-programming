
from collections import deque
import sys

# get the input dimensions and labyrinth
dimensions = input().split(' ')
list = [int(num_string) for num_string in dimensions]
row = list[0]
col = list[1]
lab = [[]]
for i in range(row):
    input_row = input()
    lab.insert(i,input_row)
#locate the start and end of the lab
start = []
end = []
for i in range(row):
    for j in range(col):
        if lab[i][j] == 'A':
            start_r = i
            start_c = j
        elif lab[i][j] == 'B':
            end = [i,j]
#init BFS
dir_r = [-1, 0, 1, 0]
dir_c = [0, -1, 0, 1]
dir_s = "ULDR"
visited = [[False for x in range(col)] for y in range(row)]
sol = [['' for x in range(col)]for y in range(row)]
queue = deque()
paths = []
queue.append((start_r,start_c))
visited.append(start)
found = False

while(queue):
    cur_r,cur_c = queue.popleft()
    #print("r = " + str(cur_r) + ", c = " + str(cur_c))
 
    if [cur_r,cur_c] == end:
        #work backwards from directional array to get the correct path
        path = []
        while not found:
            path.append(sol[cur_r][cur_c])
            if(path[-1] == 'L'):
                cur_c+=1
            elif(path[-1] == 'R'):
                cur_c-=1
            elif(path[-1] == 'U'):
                cur_r+=1
            elif(path[-1] == 'D'):
                cur_r-=1
            if(cur_c == start_c and cur_r == start_r):
                found = True
                break
        paths.append(path)
        break
    visited[cur_r][cur_c] = True
    for dir in range(4):
        r = cur_r + dir_r[dir]
        c = cur_c + dir_c[dir]
        if r >= 0 and r < row and c >= 0 and c < col and lab[r][c]!='#':
            if not visited[r][c]:
                sol[r][c] = dir_s[dir]
                queue.append((r,c))

if len(paths) > 0:
    print("YES")
    new = min(paths,key=len)
    print(len(new))
    new.reverse()
    for i in new:
        print(i,end="")
    print("")
else:
    print("NO")

